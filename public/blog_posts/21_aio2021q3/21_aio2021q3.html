<blockquote>
<p><em>Note: Online judges are not available for AIO 2021 yet, so there is no guarantee that the solution or the code will score 100. These solutions will be updated if any changes need to be made.</em></p>
</blockquote>
<p><em>Contest Source: <a href="https://orac2.info/hub/aio/">AIO 2021</a></em></p>
<div class="row download-block">
<a href="/../blog_posts/19_aio2021q1/problems/problems.pdf" class="col-md-4 download-link mb-3" download>
<div class="download-card">
<div class="row">
<div class="col-3">
<p><img class="download-icon" src="/images/icons/download_white.png"></p>
</div>
<div class="col-9">
<div class="row">
<div class="col">
<p>
problems.pdf
</p>
</div>
</div>
<div class="row">
<div class="col">
<p><span> 385.4KB </span></p>
</div>
</div>
</div>
</div>
</div>
</a>
</div>
<p>There are three ‘categories’ of notes: the first note in each triple, the second node in each triple, and the third note in each triple. The first observation is noticing that we can handle each of these three categories separately, since the notes in any one category do not affect how you have to pick any of the other categories at all.</p>
<p>Now for a given category, we obviously want to change all of them to the most frequent note in that category, in order to make the least number of changes. We can use modulo to figure out what category a number is in. The overall complexity of this solution is <span class="math inline">\(O(N)\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main () {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    freopen(<span class="st">&quot;melodyin.txt&quot;</span>, <span class="st">&quot;r&quot;</span>, stdin);</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    freopen(<span class="st">&quot;melodyout.txt&quot;</span>, <span class="st">&quot;w&quot;</span>, stdout);</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N, K;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    cin &gt;&gt; N &gt;&gt; K;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt[<span class="dv">3</span>][K+<span class="dv">5</span>] = {{<span class="dv">0</span>}}; <span class="co">// cnt[i][j] = the number of note j&#39;s in category i.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; i++) {</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> note;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        cin &gt;&gt; note;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        cnt[i%<span class="dv">3</span>][note]++;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// find the maximum occurence of a note in each category</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best[<span class="dv">3</span>] = {<span class="dv">0</span>};</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) {</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; K+<span class="dv">5</span>; j++) {</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            best[i] = max(best[i], best[i][j]);</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we now just add up the cost of converting every other note to that note</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans = ((N/<span class="dv">3</span>)-best[<span class="dv">0</span>]) + ((N/<span class="dv">3</span>)-best[<span class="dv">1</span>]) + ((N/<span class="dv">3</span>)-best[<span class="dv">2</span>]);</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>, ans);</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
