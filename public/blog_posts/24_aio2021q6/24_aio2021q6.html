<p><em>Contest Source: <a href="https://orac2.info/hub/aio/">AIO 2021</a></em></p>
<p>Observe that the top right corner and bottom left corner of an optimum square must always lie on the upper and lower boundaries respectively. If this were not the case, we would always be able to extend of the corners to form a bigger square. Also note that since it is a square, the two corners on the boundary must also lie on the same diagonal. This gives rise to a surprisingly simple solution!</p>
<p>We keep two positions <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, which correspond to the points on the top and bottom boundaries respectively. We loop a counter <span class="math inline">\(i\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(2N\)</span> and at each iteration, we move the points <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> along their respective boundaries. Notice that by incrementing <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> at the same time, they will always be in the same diagonal, regardless of what their instructions are. We can now find the size of the square based on the coordinates of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> and output the maximum square size. This is <span class="math inline">\(O(N)\)</span>, since it requires one loop through the top and bottom boundaries.</p>
<p>But in fact, we can do even better than this! Notice that the side length of the square only increases when <span class="math inline">\(a\)</span> moves to the right and <span class="math inline">\(b\)</span> moves down. Similarly, it decreases when <span class="math inline">\(a\)</span> moves to down and <span class="math inline">\(b\)</span> moves right. Finally, if <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> move in the same direction, then the side length of the square remains the same. This means that we donâ€™t even need to keep track of the two points <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, just the directions that they move in! This gives us an extremely clean solution for this problem, shown below.</p>
<h2 id="c-solution">C++ Solution</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main () {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    freopen(<span class="st">&quot;laserin.txt&quot;</span>, <span class="st">&quot;r&quot;</span>, stdin);</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    freopen(<span class="st">&quot;laserout.txt&quot;</span>, <span class="st">&quot;w&quot;</span>, stdout);</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    cin &gt;&gt; N;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    string a, b;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    cin &gt;&gt; a &gt;&gt; b;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> curr_length = <span class="dv">0</span>;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best = <span class="dv">0</span>;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>*N; i++) {</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (a[i] == <span class="ch">&#39;D&#39;</span> &amp;&amp; b[i] == <span class="ch">&#39;R&#39;</span>) curr_length++;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (a[i] == <span class="ch">&#39;R&#39;</span> &amp;&amp; b[i] == <span class="ch">&#39;D&#39;</span>) curr_length--;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        best = max(best, curr_length);</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>, best);</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
