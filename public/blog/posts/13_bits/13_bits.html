<p><em>Problem Source: <a href="https://asiasg18.kattis.com/problems">2018 Asia Singapore ICPC Regionals</a></em></p>
<p>As the name implies, we work with the bits of each number in <span class="math inline">\(A\)</span>. Let’s define a valid segmentation in terms of <span class="math inline">\(X\)</span> as dividing <span class="math inline">\(A\)</span> into <span class="math inline">\(K\)</span> contiguous non-empty segments such that each section contains <span class="math inline">\(X\)</span>. We say a section (or it’s bitwise ) contains <span class="math inline">\(X\)</span> if for every set bit in <span class="math inline">\(X\)</span>, there exists a number in the section which also has that bit set. Now suppose we had a function <span class="math inline">\(can(X)\)</span>, which tells us if there exists a valid segmentation of <span class="math inline">\(A\)</span> in terms of <span class="math inline">\(X\)</span>. The answer is now simply finding the largest value of <span class="math inline">\(X\)</span> such that <span class="math inline">\(can(X)\)</span> returns true.</p>
<h4 id="greedily-taking-bits">Greedily Taking Bits</h4>
<p>We do this by taking each bit from the most significant to the least significant greedily. Let’s assume the largest bit that can be set is the <span class="math inline">\(31^{st}\)</span> bit, so we start <span class="math inline">\(X\)</span> as all zeros, and let <span class="math inline">\(i\)</span> loop from 31 down to 1. We then run <span class="math inline">\(can(X \mid 2^{i})\)</span>, where <span class="math inline">\(\mid\)</span> is the bitwise <span class="math inline">\(\texttt{OR}\)</span>. If it returns true, then set <span class="math inline">\(X\)</span> to <span class="math inline">\(X \mid 2^{i}\)</span>. Otherwise, try again for the next <span class="math inline">\(i\)</span>. Once we have done it for all <span class="math inline">\(i\)</span>, we print out <span class="math inline">\(X\)</span> as our answer. This has the effect of working out the <span class="math inline">\(i^{th}\)</span> bit of the final answer in the <span class="math inline">\(i^{th}\)</span> iteration.</p>
<p>The reason this greedy solution works is as follows: Let’s consider the first iteration, where <span class="math inline">\(X = 0\)</span> and <span class="math inline">\(i = 31\)</span>, so <span class="math inline">\(X \mid 2^{i} = 2^{31}\)</span>. If <span class="math inline">\(can(2^{31})\)</span> returns true, then we know that the answer is at least <span class="math inline">\(2^{31}\)</span>. This means that the answer must have the <span class="math inline">\(31^{st}\)</span> bit set, since any number without the <span class="math inline">\(31^{st}\)</span> bit set is necessarily smaller than <span class="math inline">\(2^{31}\)</span> and hence suboptimal. Likewise, if there was an answer with the <span class="math inline">\(31^{st}\)</span> bit set, then <span class="math inline">\(can(2^{31})\)</span> must also return true by definition. Thus, if <span class="math inline">\(can(2^{31})\)</span> is false, then the final answer’s <span class="math inline">\(31^{st}\)</span> bit must be unset. Hence, by the end of the first iteration, we know the first bit of our answer. Once we have fixed the <span class="math inline">\(31^{st}\)</span> bit, we can then apply the same logic to fix the <span class="math inline">\(30^{th}\)</span> bit, then the <span class="math inline">\(29^{th}\)</span> bit and so on.</p>
<h4 id="finding-a-segmentation">Finding a Segmentation</h4>
<p>To implement <span class="math inline">\(can(X)\)</span>, we choose a set of ‘starting points’, which correspond to indexes in the array <span class="math inline">\(A\)</span>. For each starting point, we start a section there, then greedily make new sections by iterating along <span class="math inline">\(A\)</span> and ending a section as soon as it’s bitwise <span class="math inline">\(\texttt{OR}\)</span> contains <span class="math inline">\(X\)</span>. Notice how if we have a section that contains <span class="math inline">\(X\)</span>, then adding more numbers to it will never change the fact that it contains <span class="math inline">\(X\)</span>, so it never makes sense to add more then necessary to a section. If at any point we finish <span class="math inline">\(K\)</span> sections, then we can simply append the remaining numbers into the last section and return true. If we couldn’t make <span class="math inline">\(K\)</span> sections for any of the starting points, then we return false.</p>
<p>One way to choose starting points would be simply the set of all numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(N\)</span>, but this is too slow. Observe that not all of these starting points are useful. For example if <span class="math inline">\(A_i = 0\)</span>, then we might as well never consider <span class="math inline">\(i+1\)</span> as a starting point, since which section <span class="math inline">\(A_i\)</span> falls into is incosequential. In fact, we can get away with as little as only <span class="math inline">\(31\)</span> start points! We let the <span class="math inline">\(i^{th}\)</span> starting point <span class="math inline">\(start[i]\)</span> be the index after which the <span class="math inline">\(i^{th}\)</span> bit first appears in <span class="math inline">\(A\)</span>. In other words, all the numbers <span class="math inline">\(A_1, ... A_{start[i]}\)</span> should not contain have the <span class="math inline">\(i^{th}\)</span> bit set, but <span class="math inline">\(A_{start[i]}\)</span> should.</p>
<p>The reason why this works is as follows: We call a segmentation of <span class="math inline">\(A\)</span> valid if it partitions <span class="math inline">\(A\)</span> into <span class="math inline">\(K\)</span> parts, such that each section contains <span class="math inline">\(X\)</span>. For any valid segmentation of <span class="math inline">\(A\)</span>, we can modify it so that it is still valid, but such that the end of the section containing <span class="math inline">\(A_N\)</span> is right before a start point. Consider the section that contains <span class="math inline">\(A_N\)</span> in a valid segmentation, and let the final element in that section be <span class="math inline">\(A_i\)</span>. There are three cases to consider:</p>
<ol type="1">
<li>If <span class="math inline">\(i\)</span> is right before a start point, then no more modification is necessary.</li>
<li>Otherwise, if <span class="math inline">\(A_i = 0\)</span>, then we can move <span class="math inline">\(A_i\)</span> to the next segment, and let <span class="math inline">\(A_{i-1}\)</span> be the new end of the segment. Clearly, this operation preserves the validity of the segmentation.</li>
<li>Otherwise <span class="math inline">\(A_i \neq 0\)</span>, and none of the bits set in <span class="math inline">\(A_{i}\)</span> are the first occurence of that bit. This means that we can move <span class="math inline">\(A_{i}\)</span> to the next segment whilst preserving validity, since every set bit in <span class="math inline">\(A_{i}\)</span> will still appear in <span class="math inline">\(A_1 ... A_{i-1}\)</span>, so the segment still contains <span class="math inline">\(X\)</span>.</li>
</ol>
<p>Hence, if our segment does not end right before a start point, we can always keep removing the last element until it does. Hence any valid segmentation will start on at least one of these start points. Since our greedy algorithm is guaranteed to find a valid segmentation for a given start point if it exists, then we only need to test these 31.</p>
<p>In terms of complexity, generating start points takes <span class="math inline">\(O(N\log N)\)</span>, <span class="math inline">\(can(X)\)</span> takes <span class="math inline">\(O(N \log N)\)</span> and we run it <span class="math inline">\(\log N\)</span> times to work out each bit. Hence, our final complexity is <span class="math inline">\(O(N \log^2 N)\)</span></p>
<h2 id="coded-solution">Coded Solution</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">typedef</span> pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; pii;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">typedef</span> vector&lt;<span class="dt">int</span>&gt; vi;</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="pp">#define x </span>first</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="pp">#define y </span>second</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="pp">#define pb </span>push_back</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="pp">#define all</span>(x)<span class="pp"> </span>x.begin(),<span class="pp"> </span>x.end()</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="pp">#define rep</span>(i,<span class="pp"> </span>n)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span><span class="dv">0</span>;<span class="pp"> </span>i<span class="pp"> </span>&lt;<span class="pp"> </span><span class="dt">int</span>(n);<span class="pp"> </span>i++)</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="pp">#define per</span>(i,<span class="pp"> </span>n)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(n)-<span class="dv">1</span>;<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span><span class="dv">0</span>;<span class="pp"> </span>i--)</span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="pp">#define MAXN </span><span class="dv">500005</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="dt">int</span> N, K;</span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="dt">int</span> start[<span class="dv">32</span>];</span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="dt">int</span> a[MAXN*<span class="dv">2</span>];</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="dt">bool</span> can(<span class="dt">int</span> X) {</span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span class="co">// try for every start point</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>    rep(i, <span class="dv">31</span>) {</span>
<span id="cb1-22"><a href="#cb1-22"></a>        <span class="cf">if</span> (start[i] == -<span class="dv">1</span>) <span class="cf">continue</span>;</span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>        <span class="co">// greedily make sections</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>        <span class="dt">int</span> k = <span class="dv">0</span>;</span>
<span id="cb1-26"><a href="#cb1-26"></a>        <span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb1-27"><a href="#cb1-27"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = start[i]; j &lt; start[i] + N; j++) {</span>
<span id="cb1-28"><a href="#cb1-28"></a>            x |= a[j];</span>
<span id="cb1-29"><a href="#cb1-29"></a>            <span class="cf">if</span> ((x &amp; X) == X) k++, x = <span class="dv">0</span>; <span class="co">// end a section</span></span>
<span id="cb1-30"><a href="#cb1-30"></a>            <span class="cf">if</span> (k == K) <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb1-31"><a href="#cb1-31"></a>        }</span>
<span id="cb1-32"><a href="#cb1-32"></a>    }</span>
<span id="cb1-33"><a href="#cb1-33"></a>    <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb1-34"><a href="#cb1-34"></a>}</span>
<span id="cb1-35"><a href="#cb1-35"></a></span>
<span id="cb1-36"><a href="#cb1-36"></a><span class="dt">int</span> main () {</span>
<span id="cb1-37"><a href="#cb1-37"></a>    cin &gt;&gt; N &gt;&gt; K;</span>
<span id="cb1-38"><a href="#cb1-38"></a>    rep (i, N) cin &gt;&gt; a[i];</span>
<span id="cb1-39"><a href="#cb1-39"></a>    rep (i, N) a[i+N] = a[i];</span>
<span id="cb1-40"><a href="#cb1-40"></a></span>
<span id="cb1-41"><a href="#cb1-41"></a>    <span class="co">// generate start points for each bit</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>    fill(start, start+<span class="dv">31</span>, -<span class="dv">1</span>);</span>
<span id="cb1-43"><a href="#cb1-43"></a>    rep (i, N) rep(j, <span class="dv">31</span>) {</span>
<span id="cb1-44"><a href="#cb1-44"></a>        <span class="cf">if</span> (a[i] &amp; (<span class="dv">1</span>&lt;&lt;j) &amp;&amp; start[j] == -<span class="dv">1</span>) start[j] = (i+<span class="dv">1</span>)%N;</span>
<span id="cb1-45"><a href="#cb1-45"></a>    }</span>
<span id="cb1-46"><a href="#cb1-46"></a></span>
<span id="cb1-47"><a href="#cb1-47"></a>    <span class="co">// work out the best we can get</span></span>
<span id="cb1-48"><a href="#cb1-48"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb1-49"><a href="#cb1-49"></a>    per(i, <span class="dv">31</span>) <span class="cf">if</span> (can(ans | (<span class="dv">1</span>&lt;&lt;i))) ans |= (<span class="dv">1</span>&lt;&lt;i);</span>
<span id="cb1-50"><a href="#cb1-50"></a>    printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>, ans);</span>
<span id="cb1-51"><a href="#cb1-51"></a>}</span></code></pre></div>
